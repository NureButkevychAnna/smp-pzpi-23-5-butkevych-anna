МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ
 
 
КАФЕДРА ПРОГРАМНОЇ ІНЖЕНЕРІЇ
 


 
 
Звіт
з практичної роботи № 1 
з дисципліни Скриптові мови програмування
  
 
 


 
Виконала:                                                                     Перевірив:
ст. гр. ПЗПІ-23-5                                                          ​​​​ст. викладач кафедри ПІ
Буткевич Анна                                                             Сокорчук Ігор Петрович
 
 
 Харків 2025
1 ІСТОРІЯ ЗМІН


№
	Дата
	Версія звіту
	Опис змін та виправлень
	1
	20.04.2025
	0.1
	Створення розділів та результати
	

	

	

	

	

2 ЗАВДАННЯ


        Написати Bash скрипт, який друкуватиме на екрані ялинку із двох ярусів гілок, стовбура та шару снігу.
Наприклад таку:


      *  
    ###  
   *****  
  #######  
 *********  
    ###  
   *****  
  #######  
 *********  
    ###  
    ###  
***********  
Ялинка повинна бути симетричною.
Яруси гілок повинні утворювати правильні рівнобедрені трикутники у яких сусідні рядки відрізняються на два символи та складаються почергово
або з символів «*» або з символів «#»
наприклад як такий:


    *  
   ###  
  *****  
 #######   
Ширина усіх ярусів гілок повинна бути на 2 символи вужча ніж ширина снігу.
Висота стовбура та товщина снігу мають бути завжди такі, як у прикладі.
Висота ялинки у рядках разом з шаром снігу та ширина шару снігу в символах вказується скрипту в його параметрах при запуску.
Параметри скрипта повинні мати додатнє значення.
Вказані значення повинні округлятися до потрібних у меншу сторону.
Якщо за вказаними при запуску скрипта значеннями зобразити ялинку на екрані неможливо, скрипт повинен вивести у потік помилок сповіщення про неправильне значення аргумента і повернути відповідний результат у батьківський процес.
У скрипті потрібно обовʼязково використати такі конструкції:
if ... then ... fi  
while ... do ... done  
until ... do ... done  
for ... in .. do ... done  
for ((...)); do ... done  
У скрипті також потрібно використати функцію.  
Ім’я скрипта: ~/{імʼя-облікового-запису}-task1
Приклад виклику скрипта: ~/pzpiz-26-7-shukhevych-roman-task1 16 11
Файл скрипта повинен бути виконуваним файлом для усіх користуачів системи.
Право редагувати файл скрипта повинен мати лише власник скрипта.
3 ОПИС ВИКОНАНОЇ РОБОТИ
  
Щоб розпочати роботу зі створення Bash-скрипта, спершу потрібно створити файл, у який буде записано програмний код. Для цього в терміналі застосовується команда touch, яка створює порожній текстовий файл. Назва файлу містить дані про студента:


touch ~/smp-pzpi-23-5-butkevych-anna-pract1


Після створення файлу в нього вноситься програмний код. Розглянемо повністю програму, що виконує побудову символічної новорічної ялинки на основі введених параметрів. Весь код наведений у Додатку В.


Насамперед зазначається, що це Bash-скрипт, за допомогою шебангу:


1 #!/bin/bash


Далі йде перевірка аргументів. В першій частині виконується перевірка аргументів: скрипт очікує два числових аргументи — висоту та ширину. Висота повинна бути не меншою за 8, а ширина — в межах допустимого діапазону, що залежить від висоти (конкретно: вона має бути парною або на 1 меншою за парну висоту). Якщо умови не виконуються, скрипт виводить помилку і завершується.


  3  if (( $# != 2 || $1 < 8 || $2 < ($1 / 2 * 2) - 1 || $2 > ($1 / 2 * 2) )); then
  4      echo "Failed to build the tree" >&2
  5      exit 1


Далі обчислюється основна висота дерева (tree_lvl) як найближче менше або рівне парне число, і ширина "сніжної частини" крони (crown_span) — це просто висота мінус 1. 


 8  tree_lvl=$(( $1 / 2 * 2 ))
 9  crown_span=$(( tree_lvl - 1 ))




У рядках 11–45 описується функція generate_layer, яка відповідає за формування основної частини ялинки — гілок. Спочатку оголошуються локальні змінні. seg_depth визначає кількість рівнів кожної частини гілки — тобто скільки рядків буде вгорі і скільки внизу. seg_width встановлює максимальну ширину сегмента, яка є трохи меншою за загальну ширину, щоб забезпечити правильне візуальне вирівнювання. Змінна char ініціалізується символом *, який буде використано для малювання рядків.


Перша частина функції — цикл з рядків 16–28 — формує верхню частину гілки. Для кожного кроку обчислюється кількість символів, яка зростає на два з кожним новим рядком. Паралельно з цим обчислюється кількість відступів зліва, щоб вирівняти рядок по центру. За допомогою printf виводиться задана кількість пробілів, а потім відповідна кількість символів char. Після кожного рядка символ чергується між * та #, щоб надати дереву декоративного вигляду.


  16      for ((step = 1; step <= seg_depth; step++)); do
  17          local chars=$(( 1 + (step - 1) * 2 ))
  18          local pad=$(( ((seg_width - chars) / 2) + 1 ))
  19  
  20          printf "%${pad}s" ""
  21          printf "%${chars}s\n" | tr ' ' "$char"
  22  
  23          if [[ "$char" == "*" ]]; then
  24              char="#"
  25          else
  26              char="*"
  27          fi
  28      done


Друга частина — цикл з рядків 30–44 — формує дзеркальну нижню частину гілки. Починається не з першого рядка, а з другого, щоб не дублювати центральну лінію. Алгоритм такий самий, як у попередньому циклі: для кожного кроку обчислюється кількість символів і пробілів, далі виводиться рядок, і символ знову чергується. Завершується функція фігурною дужкою в рядку 45. У результаті обидва цикли створюють симетричну, прикрашену верхню частину дерева.
  30      step=2
  31      until [[ $step -gt seg_depth ]]; do
  32          local chars=$(( 1 + (step - 1) * 2 ))
  33          local pad=$(( ((seg_width - chars) / 2) + 1 ))
  34  
  35          printf "%${pad}s" ""
  36          printf "%${chars}s\n" | tr ' ' "$char"
  37  
  38          if [[ "$char" == "*" ]]; then
  39              char="#"
  40          else
  41              char="*"
  42          fi
  43          ((step++))
  44      done
  45  }


Після функції (рядок 47) виконується її виклик із параметрами, заснованими на обчислених висоті та ширині.


  47  generate_layer $(((tree_lvl - 1) / 2)) $((crown_span - 2))


У рядках 49–53 формується стовбур дерева. Він складається з двох рядків ###, вирівняних по центру.


  49 stem_pad=$(( (crown_span - 3) / 2 ))
  50  
  51  for part in 1 2; do
  52      printf "%${stem_pad}s###\n"
  53  done


Нарешті, в рядках 55–60 створюється "снігова основа" дерева — нижній рядок із суцільної лінії символів *, довжина якого дорівнює ширині крони (crown_span).


  55  line=0
  56  while [[ $line -lt $crown_span ]]; do
  57      printf "*"
  58      ((line++))
  59  done
  60  printf "\n"


Щоб зробити файл виконуваним, використовується команда:
chmod +x ~/smp-pzpi-23-5-butkevych-anna-pract1, яка надає файлу право на виконання. 
Перевірка прав доступу здійснюється командою:
ls -l ~/smp-pzpi-23-5-butkevych-anna-pract1, що дозволяє переконатися, чи має файл необхідні дозволи. 
Для запуску скрипта використовується команда: ~/smp-pzpi-23-5-butkevych-anna-pract1 10 9, де числа 10 і 9 — це приклад аргументів, які задають параметри побудови символьного дерева у скрипті.
Результати знаходяться в Додатку Б.










4 ВИСНОВКИ


У ході виконання лабораторної роботи було розроблено Bash-скрипт для побудови символьного зображення ялинки у текстовому режимі. Під час реалізації скрипта було опрацьовано навички перевірки вхідних параметрів, математичних обчислень у Bash, форматованого виводу символів у циклах, створення допоміжних функцій та роботи з умовними операторами. Було надано пояснення кожного етапу реалізації, включно з процедурою створення, наданням прав доступу до файлу та запуском скрипта.
Отримані результати засвідчують розуміння принципів роботи командної оболонки Bash, зокрема взаємодії з файловою системою, використання логічних умов та реалізації елементів форматованого виведення. Розроблений скрипт працює коректно відповідно до встановлених умов і демонструє можливість автоматизації виводу структурованих символьних зображень за заданими параметрами.


ДОДАТОК А
Відеозапис


Відеозапис презентації результатів лабораторної роботи: https://youtu.be/gAjK9L11Uz0


Хронологічний опис відеозапису:
0:00 - Вступ
0:26 - Початок коду
2:30 - Рівень ялинки, ширина стовбура
2:35 - Генерація крони ялинки
4:14 - Друкування рядків-символів
5:53 - Генерація слоїв
6:56 - Малювання основи
7:33 - Демонстрація роботи програми






ДОДАТОК Б
Графічні матеріали


  

Рисунок Б.1 - Тест програми для значення 15 14


  

Рисунок Б.2 - Тест програми для значення 8 7


  

Рисунок Б.3 - Тест програми для значення 18 17
ДОДАТОК В
Програмний код
В.1 { smp-pzpi-23-5-butkevych-anna-pract1-code }
GitHub репозиторій: https://github.com/NureButkevychAnna/smp-pzpi-23-5-butkevych-anna/blob/main/Pract1/smp-pzpi-23-5-butkevych-anna-pract1/smp-pzpi-23-5-butkevych-anna-pract1-code


  1  #!/bin/bash
   2  
   3  if (( $# != 2 || $1 < 8 || $2 < ($1 / 2 * 2) - 1 || $2 > ($1 / 2 * 2) )); then
   4      echo "Failed to build the tree" >&2
   5      exit 1
   6  fi
   7  
   8  tree_lvl=$(( $1 / 2 * 2 ))
   9  crown_span=$(( tree_lvl - 1 ))
  10  
  11  generate_layer() {
  12      local seg_depth=$(( (tree_lvl - 2) / 2 ))
  13      local seg_width=$(( crown_span - 2 ))
  14      local char="*"
  15  
  16      for ((step = 1; step <= seg_depth; step++)); do
  17          local chars=$(( 1 + (step - 1) * 2 ))
  18          local pad=$(( ((seg_width - chars) / 2) + 1 ))
  19  
  20          printf "%${pad}s" ""
  21          printf "%${chars}s\n" | tr ' ' "$char"
  22  
  23          if [[ "$char" == "*" ]]; then
  24              char="#"
  25          else
  26              char="*"
  27          fi
  28      done
  29  
  30      step=2
  31      until [[ $step -gt seg_depth ]]; do
  32          local chars=$(( 1 + (step - 1) * 2 ))
  33          local pad=$(( ((seg_width - chars) / 2) + 1 ))
  34  
  35          printf "%${pad}s" ""
  36          printf "%${chars}s\n" | tr ' ' "$char"
  37  
  38          if [[ "$char" == "*" ]]; then
  39              char="#"
  40          else
  41              char="*"
  42          fi
  43          ((step++))
  44      done
  45  }
  46  
  47  generate_layer $(((tree_lvl - 1) / 2)) $((crown_span - 2))
  48  
  49  stem_pad=$(( (crown_span - 3) / 2 ))
  50  
  51  for part in 1 2; do
  52      printf "%${stem_pad}s###\n"
  53  done
  54  
  55  line=0
  56  while [[ $line -lt $crown_span ]]; do
  57      printf "*"
  58      ((line++))
  59  done
  60  printf "\n"