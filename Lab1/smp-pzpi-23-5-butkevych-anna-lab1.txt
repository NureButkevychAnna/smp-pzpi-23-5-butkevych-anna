МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ
 
 
КАФЕДРА ПРОГРАМНОЇ ІНЖЕНЕРІЇ
 


 
 
Звіт
з лабораторної роботи № 1 
з дисципліни Скриптові мови програмування
  
 
 


 
Виконала:                                                                     Перевірив:
ст. гр. ПЗПІ-23-5                                                          ​​​​ст. викладач кафедри ПІ
Буткевич Анна                                                             Сокорчук Ігор Петрович
 
 
 Харків 2025
1 ІСТОРІЯ ЗМІН


№
	Дата
	Версія звіту
	Опис змін та виправлень
	1
	21.04.2025
	0.1
	Створення розділів та результати
	

	

	

	

	

2 ЗАВДАННЯ


        Мета роботи:
Ознайомитися з основними командами Bash для роботи з файлами та текстовими даними. Навчитися використовувати команди select, ls, awk, sort, uniq, tee, cat, sed, iconv тощо
Розробити Bash-скрипт для перетворення CSV файла розкладу занять у придатний для імпорту в Google Календар CSV формат


Завдання
Розробити Bash-скрипт, який обробляє експортований із сайту https://cist.nure.ua/ розклад занять для всіх груп потоку в форматі CSV та перетворює його у формат CSV для завантаження в Google Календар https://support.google.com/.


Вимоги до скрипта
Ім’я скрипта:
~/{імʼя-облікового-запису}-task2
Синтаксис виклику:
{імʼя-облікового-запису}-task2 [--help | --version] | [[-q|--quiet] [академ_група] файл_із_cist.csv]
Приклад виклику:
pzpi-23-12-koval-vasyl-task2 'ПЗПІ-23-12' TimeTable_15_03_2025.csv
Ключі:
--help — вивести довідку, завершити роботу та повернути успішний результат у батьківський процес
--version — вивести інформацію про версію, завершити роботу та повернути успішний результат у батьківський процес
-q або --quiet — не виводити інформацію в стандартний потік виведення
Параметри:
академ_група — назва академічної групи (шаблон)
файл_із_cist.csv — експортований CSV файл розкладу занять
Якщо при виклику скрипта не вказана академічна група або вхідний CSV файл, то скрипт повинен:
Вивести меню вибору файла за допомогою команди select та сформувати відсортований за датою в іменах файлів (від старіших до новіших) список доступних у поточній директорії CSV файлів за шаблоном:


TimeTable_??_??_20??.csv
Відкрити вибраний CSV файл та згенерувати список академічних груп, що містяться у файлі, відсортувати їх за алфавітом (sort, uniq) та вивести меню вибору групи за допомогою select.


Обробка файла:
Читати вхідний CSV файл та вибирати рядки, що відповідають вибраній академічній групі.


Визначити порядкий номер для кожного заняття (лекція, практичне заняття, лабораторна робота) із врахуванням того, що лабораторні роботи складаються із двох пар, а решта занять — із однієї пари.


Створити поле «Subject» із поля «Тема» вхідного CSV файла, але БЕЗ назви академічної групи та дефіса на початку цього поля ("ПЗПІ-23-1 - ПрПА Пз DL ПЗПІ-23-1")


Додати порядковий номер наприкінці теми (Subject) кожного заняття після крапки з комою (опис заняття; №1)


Переформатувати дату та час до формату «mm/dd/yyyy, HH:MM AM|PM,» Gogle Календаря 12-годинний формат часу. Наприклад: 02/30/2025, 11:15 AM,


Заповнити поле «Description» текстом із поля «Опис (Описание)» вхідного CSV файла


Відформатувати дані відповідно до вимог Google Календаря https://support.google.com/calendar/.


Виводити створені для Google Календаря дані у стандартний потік виведення, якщо це не заблоковано ключем -q або --quiet


Записати результат у новий файл із назвою:


Google_TimeTable_??_??_20??.csv
де ??_??_20?? — дата, що відповідає вхідному файлу.


Обробка помилок:
Якщо файл не знайдено або файл є недоступним для читання, вивести повідомлення про помилку в стандартний потік помилок та повернути код помилки.
Якщо група не знайдена у вибраному файлі, повідомити про це користувача та запропонувати вибір іншої групи.
Якщо група не вказана, але у вказаному файлі присутня лише одна група, створити CSV файл Google Календаря для цієї групи.
Якщо сталася помилка під час обробки файла, повідомити про це та завершити роботу з відповідним кодом помилки.
Команди, які рекомендується використати у скрипті:
select — створення меню вибору файла та групи
ls — отримання списку доступних CSV файлів
awk — фільтрація та обробка даних CSV файла
sort — сортування даних (груп, дат тощо)
uniq — усунення дублікатів у списку груп
tee — збереження вихідних даних у файл та вивід на екран
cat — перегляд вмісту файла
sed — видалення зайвих пробілів, форматування дат, заміна символів
iconv — перетворення кодування файлів (Windows-1251 → UTF-8)
Результат роботи скрипта:
При виконанні скрипта створюється CSV файл, готовий для імпорту в Google Календар.
Послідовність полів у CSV файлі: Subject, Start date, Start time, End date, End time, Description
Файл містить коректно відформатовані дані про розклад занять для вибраної академічної групи.
Додаткові вимоги до скрипта:
Скрипт має необхідні права доступу:
Файл скрипта виконуваний для всіх користувачів
Редагування файла скрипта дозволене лише власнику файла
3 ОПИС ВИКОНАНОЇ РОБОТИ
  
Під час виконання лабораторної роботи було розроблено Bash-скрипт, який реалізує повний цикл обробки даних: від взаємодії з користувачем до генерації фінального файлу. Було застосовано низку інженерних рішень та інструментів для забезпечення надійності, сумісності та функціональності скрипта.


1. Загальна архітектура та підхід


В якості основи було обрано підхід, що базується на філософії Unix: конвеєрна обробка (pipeline). Скрипт не намагається виконати все за допомогою одного інструменту, а послідовно передає дані через ланцюжок спеціалізованих утиліт (iconv -> grep -> awk -> sort -> awk), де кожна виконує свою чітко визначену задачу. Це забезпечує гнучкість, модульність та легкість у налагодженні. Головним інструментом оркестрації виступає командна оболонка Bash.


2. Реалізація функціональних модулів та інженерні рішення


Скрипт можна умовно розділити на декілька функціональних блоків:


2.1. Обробка аргументів командного рядка та інтерактивний режим
Для парсингу ключів (--help, --version, -q) та позиційних аргументів (група, файл) було реалізовано стандартний цикл while з оператором case. Якщо користувач не вказав вхідні дані, скрипт переходить в інтерактивний режим, реалізований за допомогою команди select.


Формування меню вибору файлу (рядки 71-84)


71  # Інтерактивний режим
72  if [[ -z "$source_csv" ]]; then
73      PS3="Будь ласка, виберіть файл розкладу: "
74      files=()
75      while IFS= read -r file_choice; do
76          if [[ -n "$file_choice" ]]; then files+=("$file_choice"); fi
77      done < <(ls -v TimeTable_??_??_20??.csv 2>/dev/null)
78      if [[ ${#files[@]} -eq 0 ]]; then
79          error_exit "У поточній директорії не знайдено файлів розкладу."
80      fi
81      
82      select choice in "${files[@]}"; do
83          if [[ -n "$choice" ]]; then source_csv=$choice; break; fi
84      done
85  fi


Цей підхід, що використовує цикл while read, є більш сумісним зі старими версіями Bash у порівнянні з командою mapfile.


2.2. Підготовка та нормалізація даних (ключове інженерне рішення)
Було виявлено, що вхідні файли мають дві проблеми, які унеможливлюють їх коректну обробку: кодування WINDOWS-1251 та символи кінця рядка формату Windows (CRLF). Для вирішення цих проблем було застосовано підхід з використанням тимчасового файлу (mktemp).


Перекодування та очищення вхідного файлу (рядки 92-95)


92  # 1. Підготовка файлу (перекодування та очищення)
93  TEMP_UTF8=$(mktemp)
94  iconv -f WINDOWS-1251 -t UTF-8 "$source_csv" | tr -d '\r' > "$TEMP_UTF8"
95  if [[ ! -s "$TEMP_UTF8" ]]; then error_exit "Не вдалося перекодувати файл."; fi


Вся подальша робота ведеться виключно з цією "чистою" копією ($TEMP_UTF8), що гарантує стабільність роботи наступних команд (grep, awk, sort).


2.3. Фільтрація та сортування даних
Цей етап реалізовано на основі логіки, яка довела свою ефективність для специфічного формату вхідного файлу, де поля взяті в лапки.


Конвеєр фільтрації та сортування (рядки 126-140)


126 # 3. Фільтрація рядків за обраною групою (ключова логіка)
127 TEMP_FILTERED=$(mktemp)
128 grep -o "\"$target_group - [^\"]*\",\"[^\"]*\",\"[^\"]*\",\"[^\"]*\",\"[^\"]*\"" "$TEMP_UTF8" > "$TEMP_FILTERED"
129 
130 if [[ ! -s "$TEMP_FILTERED" ]]; then
131     error_exit "Не знайдено жодного запису для групи '$target_group'."
132 fi
133 
134 # 4. Сортування відфільтрованих рядків (ключова логіка)
135 TEMP_SORTED=$(mktemp)
136 awk -F'"' '{
137     split($4, date_parts, ".");
138     sort_key = date_parts[3] date_parts[2] date_parts[1] $6;
139     print sort_key "|" $0;
140 }' "$TEMP_FILTERED" | sort | cut -d'|' -f2- > "$TEMP_SORTED"


Використання grep -o дозволяє надійно відкинути пошкоджені рядки, а сортування через awk і cut забезпечує правильну хронологічну послідовність занять.


2.4. Фінальне форматування та генерація CSV
Основна логіка перетворення даних реалізована в фінальному виклику awk.


Розбір рядка: Для обробки файлу застосовано ключове рішення: використання лапок як роздільника полів (-F'\"').


Форматування часу: Для забезпечення сумісності з різними ОС (зокрема, macOS) було реалізовано вбудовану в awk функцію format_time_12h.


Фрагмент коду awk для форматування часу та нумерації занять (рядки 144-173)


144 # Вбудована функція для форматування часу (сумісна з macOS)
145 function format_time_12h(time24) {
146     split(time24, parts, ":");
147     h = parts[1] + 0; m = parts[2];
148     ampm = (h < 12 || h == 24) ? "AM" : "PM";
149     h = h % 12;
150     if (h == 0) h = 12;
151     return sprintf("%d:%s %s", h, m, ampm);
152 }
153 {
154     # ... (отримання полів) ...
155 
156     # Надійна нумерація занять
157     lesson_key = subject;
158     gsub(/ DL.*/, "", lesson_key); # Видаляємо " DL..." для унікальності
159     lesson_counters[lesson_key]++;
160     lesson_number = lesson_counters[lesson_key];
161 
162     final_subject = subject "; №" lesson_number;
163 
164     # ... (генерація фінального рядка) ...
165     printf("\"%s\",%s,\"%s\",%s,\"%s\",\"%s\"\n",
166            final_subject, google_date, google_start_time, google_date, google_end_time, description);
167 }


Такий підхід робить скрипт незалежним від зовнішньої утиліти date. Нумерація занять реалізована за допомогою асоціативного масиву в awk, що є ефективним і надійним рішенням.


3. Використані інструменти та технології


Bash: Основна оболонка для написання скрипта, керування логікою та запуску команд.


select: Створення інтерактивних меню для вибору файлу та групи.


ls, sort, grep, tr, cut: Стандартні утиліти Unix для пошуку файлів, сортування, фільтрації та обробки тексту.


iconv: Ключовий інструмент для перетворення кодування файлів з WINDOWS-1251 на UTF-8.


sed: Використовується для простих замін у рядках при формуванні імені вихідного файлу.


awk: Основний інструмент для обробки та форматування даних, реалізації сортування, перетворення часу та генерації фінального виводу.


mktemp: Створення унікальних тимчасових файлів для безпечної проміжної обробки даних.




Результати знаходяться в Додатку Б.










4 ВИСНОВКИ


В результаті виконання роботи було розроблено функціональний та надійний Bash-скрипт, що повністю відповідає поставленим вимогам. Застосовані інженерні рішення, такі як попередня нормалізація даних, використання тимчасових файлів, вбудовані в awk функції та конвеєрна обробка, дозволили створити продукт, стійкий до проблем з кодуванням та сумісний з різними Unix-подібними системами. Робота продемонструвала глибоке розуміння принципів роботи командного рядка та стандартних утиліт.


ДОДАТОК А
Відеозапис


Відеозапис презентації результатів лабораторної роботи: https://youtu.be/miQLRaF_oSM


Хронологічний опис відеозапису:
0:00 - Вступ
0:10 - Налаштування та змінні
0:39 - Функції допомоги
1:19 - Основна логіка
1:22 - Обробка аргументів
2:01 - Інтерактивний режим
2:43 - Крок 1. Перевірка вибору
2:46 - Підготовка файлу
3:04 - Пошук групи
3:30 - Обробка
3:48 - Фільтрація
3:55 - Сортування
4:00 - Фінальне форматування
5:32 - Вивід результатів
6:28 - Демонстрація роботи програми
6:47 - Завантаження у календар та імпортування файлу






ДОДАТОК Б
Графічні матеріали


  

Рисунок Б.1 - Демонстрація роботи консолі


  

Рисунок Б.2 - Результат імпортовано розкладу в Google календарі




ДОДАТОК В
Програмний код


В.1 { smp-pzpi-23-5-butkevych-anna-lab1-code }
GitHub репозиторій: https://github.com/NureButkevychAnna/smp-pzpi-23-5-butkevych-anna/blob/main/Lab1/smp-pzpi-23-5-butkevych-anna-lab1/smp-pzpi-23-5-butkevych-anna-lab1-code


1   #!/bin/bash
2
3   # === Налаштування та змінні ===
4   SCRIPT_NAME=$(basename "$0")
5   VERSION="0.1"
6   TEMP_UTF8=""
7   TEMP_FILTERED=""
8   TEMP_SORTED=""
9
10  trap 'rm -f "$TEMP_UTF8" "$TEMP_FILTERED" "$TEMP_SORTED"' EXIT
11
12  # === Функції ===
13  function display_help() {
14      cat << EOF
15  Використання: $0 [--help | --version] | [[-q|--quiet] [академ_група] файл_із_cist.csv]
16  Скрипт для перетворення CSV-файлу розкладу.
17  EOF
18      exit 0
19  }
20
21  function display_version() {
22      echo "$SCRIPT_NAME версія $VERSION"
23      exit 0
24  }
25
26  function error_exit() {
27      echo "$SCRIPT_NAME: Помилка: $1" >&2
28      exit 1
29  }
30
31  # === Основна логіка ===
32
33  # --- Обробка аргументів ---
34  is_quiet=false
35  target_group=""
36  source_csv=""
37
38  args_copy=("$@")
39  for arg in "${args_copy[@]}"; do
40      case "$arg" in
41          --help) display_help ;;
42          --version) display_version ;;
43          -q|--quiet) is_quiet=true ;;
44      esac
45  done
46
47  for arg in "$@"; do
48      case "$arg" in -q|--quiet) shift ;; *) ;; esac
49  done
50  if [[ $# -gt 0 ]]; then target_group=$1; fi
51  if [[ $# -gt 1 ]]; then source_csv=$2; fi
52
53  # --- Інтерактивний режим ---
54  if [[ -z "$source_csv" ]]; then
55      PS3="Будь ласка, виберіть файл розкладу (введіть номер): "
56      files=()
57      while IFS= read -r file_choice; do
58          if [[ -n "$file_choice" ]]; then files+=("$file_choice"); fi
59      done < <(ls -v TimeTable_??_??_20??.csv 2>/dev/null)
60      if [[ ${#files[@]} -eq 0 ]]; then error_exit "У поточній директорії не знайдено файлів розкладу."; fi
61      
62      select choice in "${files[@]}"; do
63          if [[ -n "$choice" ]]; then source_csv=$choice; break; fi
64      done
65  fi
66
67  if [[ ! -f "$source_csv" ]] || [[ ! -r "$source_csv" ]]; then
68      error_exit "Файл '$source_csv' недоступний для читання."
69  fi
70
71  # -----
72  echo -e "\n--- Крок 1: Перевірка вибору ---"
73  echo "Ви обрали вхідний файл: '$source_csv'"
74
75  # 1. Підготовка файлу
76  TEMP_UTF8=$(mktemp)
77  iconv -f WINDOWS-1251 -t UTF-8 "$source_csv" | tr -d '\r' > "$TEMP_UTF8"
78  if [[ ! -s "$TEMP_UTF8" ]]; then error_exit "Не вдалося перекодувати файл."; fi
79
80  # 2. Пошук груп
81  if [[ -z "$target_group" ]]; then
82      groups=()
83      while IFS= read -r group_choice; do
84          if [[ -n "$group_choice" ]]; then groups+=("$group_choice"); fi
85      done < <(grep -o -E '[А-ЯІЇЄ]{2,4}-[0-9]{2,}-[0-9]{1,2}' "$TEMP_UTF8" | sort -u)
86      if [[ ${#groups[@]} -eq 0 ]]; then error_exit "У файлі не знайдено жодної групи."; fi
87      
88      if [[ ${#groups[@]} -eq 1 ]]; then
89          target_group="${groups[0]}"
90      else
91          echo "Виберіть групу:" >&2
92          PS3="Ваш вибір: "
93          select choice in "${groups[@]}"; do
94              if [[ -n "$choice" ]]; then target_group=$choice; break; fi
95          done
96      fi
97  fi
98  echo "Ви обрали групу: '$target_group'"
99
100
101 # --- Обробка ---
102 # Надійний спосіб отримати дату з імені файлу
103 date_part=$(echo "$source_csv" | sed -e 's/^.*TimeTable_//' -e 's/\.csv$//')
104 # Створюємо файл на робочому столі
105 output_csv_path="$HOME/Desktop/Google_TimeTable_${date_part}.csv"
106
107 echo -e "\n--- Крок 2: Обробка даних ---"
108 echo "Я буду створювати файл з назвою: $(basename "$output_csv_path")"
109 echo "За адресою: $output_csv_path"
110
111 # Фільтрація
112 TEMP_FILTERED=$(mktemp)
113 grep -o "\"$target_group - [^\"]*\",\"[^\"]*\",\"[^\"]*\",\"[^\"]*\",\"[^\"]*\"" "$TEMP_UTF8" > "$TEMP_FILTERED"
114 if [[ ! -s "$TEMP_FILTERED" ]]; then
115     error_exit "Не знайдено жодного запису для групи '$target_group'. (Крок фільтрації не дав результатів)"
116 fi
117
118 # Сортування
119 TEMP_SORTED=$(mktemp)
120 awk -F'"' '{ split($4, d, "."); print d[3]d[2]d[1]$6"|"$0; }' "$TEMP_FILTERED" | sort | cut -d'|' -f2- > "$TEMP_SORTED"
121
122 # Фінальне форматування
123 echo "Subject,Start Date,Start Time,End Date,End Time,Description" > "$output_csv_path"
124 awk -F'"' -v group_prefix="$target_group - " '
125     function format_time_12h(time24) {
126         split(time24, parts, ":");
127         h = parts[1] + 0; m = parts[2];
128         ampm = (h < 12 || h == 24) ? "AM" : "PM";
129         h = h % 12; if (h == 0) h = 12;
130         return sprintf("%d:%s %s", h, m, ampm);
131     }
132     {
133         subject_raw = $2; start_date = $4; start_time = $6; end_date = $8; end_time = $10;
134         if (subject_raw == "" || start_date ~ /Дата/) next;
135         split(start_date, d_parts, ".");
136         google_date = d_parts[2] "/" d_parts[1] "/" d_parts[3];
137         google_start_time = format_time_12h(start_time);
138         google_end_time = format_time_12h(end_time);
139         subject = subject_raw; sub(group_prefix, "", subject);
140         lesson_key = subject; gsub(/ DL.*/, "", lesson_key);
141         lesson_counters[lesson_key]++; lesson_number = lesson_counters[lesson_key];
142         final_subject = subject "; №" lesson_number; description = subject_raw;
143         printf("\"%s\",%s,\"%s\",%s,\"%s\",\"%s\"\n",
144                final_subject, google_date, google_start_time, google_date, google_end_time, description);
145     }
146 ' "$TEMP_SORTED" >> "$output_csv_path"
147
148 # --- Вивід результату ---
149 if [[ "$is_quiet" = false ]]; then
150     if [[ -s "$output_csv_path" ]]; then
151         echo -e "\n--- Крок 3: Завершення ---"
152         echo "Файл успішно створено на вашому РОБОЧОМУ СТОЛІ."
153         echo "Назва файлу: $(basename "$output_csv_path")"
154         echo "Зараз я спробую його відкрити..."
155         
156         sleep 2 # Невелика пауза, щоб ви встигли прочитати
157         
158         # `open` - це стандартна команда macOS для відкриття файлів
159         if command -v open &> /dev/null; then
160             open "$output_csv_path"
161         else
162             echo "Команда 'open' не знайдена. Будь ласка, відкрийте файл вручну з вашого робочого столу."
163         fi
164     else
165         error_exit "Не вдалося створити записи. Фінальний файл порожній."
166         rm "$output_csv_path"
167     fi
168 fi
169
170 exit 0